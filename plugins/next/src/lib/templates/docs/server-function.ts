import { camelCase, mdLiteral, pascalCase, ResourceDescriptor, RestData } from "@intrig/plugin-sdk"

export function serverFunctionDocs(descriptor: ResourceDescriptor<RestData>) {
  const md = mdLiteral('server-function.md')

  // ===== Derived names (preserve these) =====
  const hasPathParams = (descriptor.data.variables ?? []).some(
    (v: any) => v.in?.toUpperCase() === 'PATH',
  )

  const actionName = camelCase(descriptor.name)                  // e.g. getUser
  const executeActionName = `execute${pascalCase(descriptor.name)}`  // e.g. executeGetUser

  const requestBodyVar = descriptor.data.requestBody
    ? camelCase(descriptor.data.requestBody)                    // e.g. createUser
    : undefined
  const requestBodyType = descriptor.data.requestBody
    ? pascalCase(descriptor.data.requestBody)                   // e.g. CreateUser
    : undefined

  const paramsVar = hasPathParams ? `${actionName}Params` : undefined          // e.g. getUserParams
  const paramsType = hasPathParams ? `${pascalCase(descriptor.name)}Params` : undefined // e.g. GetUserParams
  const responseTypeName = `${pascalCase(descriptor.name)}Response`        // e.g. GetUserResponse

  const callArgs = [requestBodyVar, paramsVar].filter(Boolean).join(', ')

  return md`
# Server-Side Functions — Quick Guide

## Copy-paste starter (fast lane)

### 1) Function import (in your Next.js API route or server component)
${"```ts"}
import { ${actionName}, ${executeActionName} } from '@intrig/react/${descriptor.path}/server';
${"```"}

### 2) Use the async function
${"```ts"}
// Simple usage - returns parsed response
const result = await ${actionName}(${callArgs});

// Advanced usage - returns raw data + headers
const { data, headers } = await ${executeActionName}(${callArgs});
${"```"}

Server-side functions are for **Next.js API routes** and **server components**. They return **awaitable promises** that directly call your backend API.

---

## TL;DR (copy–paste examples)

### In API Route (\`pages/api\` or \`app/api\`)
${"```ts"}
// pages/api/example.ts or app/api/example/route.ts
import { ${actionName} } from '@intrig/react/${descriptor.path}/server';
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const result = await ${actionName}(${callArgs});
    res.status(200).json(result);
  } catch (error) {
    console.error('API call failed:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
${"```"}

### In Server Component (App Router)
${"```tsx"}
// app/example/page.tsx
import { ${actionName} } from '@intrig/react/${descriptor.path}/server';

export default async function ExamplePage() {
  try {
    const data = await ${actionName}(${callArgs});
    
    return (
      <div>
        <h1>Server Data</h1>
        <pre>{JSON.stringify(data, null, 2)}</pre>
      </div>
    );
  } catch (error) {
    return <div>Error loading data: {error.message}</div>;
  }
}
${"```"}

### In Server Action (App Router)
${"```ts"}
// app/actions.ts
'use server';

import { ${actionName} } from '@intrig/react/${descriptor.path}/server';

export async function serverAction(formData: FormData) {
  try {
    const result = await ${actionName}(${callArgs});
    // Process result...
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error.message };
  }
}
${"```"}

${requestBodyType || paramsType ? `### Optional types (if generated by your build)
${"```ts"}
${requestBodyType ? `import type { ${requestBodyType} } from '@intrig/react/${descriptor.source}/components/schemas/${requestBodyType}';
` : ''}${paramsType ? `import type { ${paramsType} } from '@intrig/react/${descriptor.path}/${pascalCase(descriptor.name)}.params';
` : ''}import type { ${responseTypeName} } from '@intrig/react/${descriptor.path}/${pascalCase(descriptor.name)}.response';
${"```"}
` : ''}

---

## Function API

${"```ts"}
// Prefer concrete types if your build emits them:
// import type { ${responseTypeName} } from '@intrig/react/${descriptor.path}/${pascalCase(descriptor.name)}.response';
// ${paramsType ? `import type { ${paramsType} } from '@intrig/react/${descriptor.path}/${pascalCase(descriptor.name)}.params';` : ''}

type ${pascalCase(descriptor.name)}Data = ${'unknown'}; // replace with ${responseTypeName} if generated
type ${pascalCase(descriptor.name)}Request = {
  body?: ${requestBodyType ?? 'unknown'};
  params?: ${paramsType ?? 'unknown'};
};

// Main function - returns parsed response
declare function ${actionName}(
  ${requestBodyVar ? `body: ${pascalCase(descriptor.name)}Request['body'], ` : ''}${paramsVar ? `params: ${pascalCase(descriptor.name)}Request['params'], ` : ''}options?: AsyncRequestOptions
): Promise<${pascalCase(descriptor.name)}Data>;

// Advanced function - returns raw data + headers
declare function ${executeActionName}(
  ${requestBodyVar ? `body: ${pascalCase(descriptor.name)}Request['body'], ` : ''}${paramsVar ? `params: ${pascalCase(descriptor.name)}Request['params'], ` : ''}options?: AsyncRequestOptions
): Promise<{ data: any, headers: any }>;
${"```"}

### Why server-side functions?
- **Server-only execution:** Perfect for Next.js API routes and server components.
- **Direct API calls:** No client-side state management needed.
- **SSR/SSG friendly:** Use in \`getServerSideProps\`, \`getStaticProps\`, or server components.
- **Built-in error handling:** Automatic network and validation error handling.

### Options
Both functions accept an optional \`options\` parameter:

${"```ts"}
type AsyncRequestOptions = {
  hydrate?: boolean;  // Cache response for client-side hydration
  key?: string;      // Custom cache key (when hydrate is true)
};
${"```"}

### Error Handling
Server-side functions throw errors for:
- **Network errors:** Connection issues, HTTP error status codes
- **Validation errors:** Response doesn't match expected schema
- **Request errors:** Invalid request body or parameters

Always wrap calls in try-catch blocks for production use.

---

## Next.js Integration Patterns

### 1. API Routes (Pages Router)
Use server functions in your API routes to proxy requests or process data server-side.

### 2. Server Components (App Router)
Directly call server functions in your server components for SSR data fetching.

### 3. Server Actions (App Router)
Use server functions within server actions for form submissions and mutations.

### 4. Middleware
Server functions can be used in Next.js middleware for request preprocessing.

### 5. getServerSideProps / getStaticProps (Pages Router)
Perfect for data fetching in traditional Next.js data fetching methods.

---

## Best Practices

1. **Error boundaries:** Always handle errors appropriately for your use case
2. **Caching:** Use the \`hydrate\` option for data that should be available client-side
3. **Types:** Import and use the generated TypeScript types for better DX
4. **Logging:** Server functions include built-in logging for debugging

${"```ts"}
// Example with proper error handling and types
import { ${actionName} } from '@intrig/react/${descriptor.path}/server';
${paramsType ? `import type { ${paramsType} } from '@intrig/react/${descriptor.path}/${pascalCase(descriptor.name)}.params';` : ''}
import type { ${responseTypeName} } from '@intrig/react/${descriptor.path}/${pascalCase(descriptor.name)}.response';

export async function fetchData(${paramsVar ? `params: ${paramsType}` : ''}): Promise<${responseTypeName} | null> {
  try {
    return await ${actionName}(${callArgs});
  } catch (error) {
    console.error('Failed to fetch data:', error);
    return null;
  }
}
${"```"}
`;
}