import { camelCase, mdLiteral, pascalCase, ResourceDescriptor, RestData } from "common";

export function reactSseHookDocs(descriptor: ResourceDescriptor<RestData>) {
  const md = mdLiteral("sse-hook.md");

  // ===== Derived names =====
  const hasPathParams = (descriptor.data.variables ?? []).some(
    (v: any) => v.in?.toUpperCase() === "PATH",
  );

  const actionName = camelCase(descriptor.name);                 // e.g. streamBuildLogs
  const respVar = `${actionName}Resp`;                           // e.g. streamBuildLogsResp
  const clearName = `clear${pascalCase(descriptor.name)}`;       // e.g. clearStreamBuildLogs

  const requestBodyVar = descriptor.data.requestBody
    ? camelCase(descriptor.data.requestBody)
    : undefined;
  const requestBodyType = descriptor.data.requestBody
    ? pascalCase(descriptor.data.requestBody)
    : undefined;

  const paramsVar = hasPathParams ? `${actionName}Params` : undefined;           // e.g. streamBuildLogsParams
  const paramsType = hasPathParams ? `${pascalCase(descriptor.name)}Params` : undefined; // e.g. StreamBuildLogsParams

  const responseTypeName = `${pascalCase(descriptor.name)}ResponseBody`; // if generated by your build
  const callArgs = [requestBodyVar, paramsVar ?? "{}"].filter(Boolean).join(", ");

  return md`
# Intrig SSE Hooks — Quick Guide

## When should I use the SSE hook?
- **Your endpoint streams events** (Server-Sent Events) and you want **incremental updates** in the UI → use this **SSE hook**.
- **You only need a final result** → use the regular **stateful hook**.
- **One-off validate/submit/update** with no shared state → use the **async hook**.

> Intrig SSE hooks are **stateful hooks** under the hood. **Events arrive while the hook is in \`Pending\`**. When the stream completes, the hook transitions to **\`Success\`** (or **\`Error\`**).

---

## Copy-paste starter (fast lane)

### 1) Hook import
\`\`\`ts
import { use${pascalCase(descriptor.name)} } from '@intrig/react/${descriptor.path}/client';
\`\`\`

### 2) Utility guards
\`\`\`ts
import { isPending, isSuccess, isError } from '@intrig/react';
\`\`\`

### 3) Hook instance (auto-clear on unmount)
\`\`\`ts
const [${respVar}, ${actionName}] = use${pascalCase(descriptor.name)}({ clearOnUnmount: true });
\`\`\`

---

## TL;DR (copy–paste)

\`\`\`tsx
import { use${pascalCase(descriptor.name)} } from '@intrig/react/${descriptor.path}/client';
import { isPending, isSuccess, isError } from '@intrig/react';
import { useEffect, useState } from 'react';

export default function Example() {
  const [${respVar}, ${actionName}] = use${pascalCase(descriptor.name)}({ clearOnUnmount: true });
  const [messages, setMessages] = useState<any[]>([]);

  useEffect(() => {
    ${actionName}(${callArgs}); // start stream
  }, [${actionName}]);

  useEffect(() => {
    // SSE delivers messages while state is Pending
    if (isPending(${respVar})) {
      setMessages((prev) => [...prev, ${respVar}.data]);
    }
  }, [${respVar}]);

  if (isError(${respVar})) return <>An error occurred</>;
  if (isPending(${respVar})) return <pre>{JSON.stringify(messages, null, 2)}</pre>;
  if (isSuccess(${respVar})) return <>Completed</>;

  return null;
}
\`\`\`

${(requestBodyType || paramsType) ? `### Optional types (if generated by your build)
\`\`\`ts
${requestBodyType ? `import type { ${requestBodyType} } from '@intrig/react/${descriptor.source}/components/schemas/${requestBodyType}';\n` : ''}${paramsType ? `import type { ${paramsType} } from '@intrig/react/${descriptor.path}/${pascalCase(descriptor.name)}.params';\n` : ''}import type { ${responseTypeName} } from '@intrig/react/${descriptor.path}/${pascalCase(descriptor.name)}.response';
\`\`\`
` : ''}

---

## Hook API

\`\`\`ts
// Signature (shape shown; concrete generics vary per generated hook)
declare function use${pascalCase(descriptor.name)}(options?: {
  fetchOnMount?: boolean;
  clearOnUnmount?: boolean;   // recommended for streams
  key?: string;               // isolate multiple subscriptions
  params?: ${paramsType ?? 'unknown'};
  body?: ${requestBodyType ?? 'unknown'};
}): [
  // While streaming: isPending(state) === true and state.data is the latest event
  NetworkState<${responseTypeName} /* or event payload type */, any>,
  // Start streaming:
  (req: { params?: ${paramsType ?? 'unknown'}; body?: ${requestBodyType ?? 'unknown'} }) => void,
  // Clear/close stream:
  () => void
];
\`\`\`

> **Important:** For SSE, **each incoming event** is surfaced as \`${respVar}.data\` **only while** \`isPending(${respVar})\` is true. On stream completion the hook flips to \`isSuccess\`.

---

## Usage patterns

### 1) Lifecycle-bound stream (start on mount, auto-clear)
\`\`\`tsx
const [${respVar}, ${actionName}] = use${pascalCase(descriptor.name)}({ clearOnUnmount: true });

useEffect(() => {
  ${actionName}(${callArgs});
}, [${actionName}]);
\`\`\`
<details><summary>Description</summary>
Starts the stream when the component mounts and closes it when the component unmounts.
</details>

### 2) Collect messages into an array (simple collector)
\`\`\`tsx
const [messages, setMessages] = useState<any[]>([]);

useEffect(() => {
  if (isPending(${respVar})) setMessages((m) => [...m, ${respVar}.data]);
}, [${respVar}]);
\`\`\`
<details><summary>Description</summary>
Appends each event to an in-memory array. Good for logs and chat-like feeds; consider capping length to avoid memory growth.
</details>

### 3) Keep only the latest event (cheap UI)
\`\`\`tsx
const latest = isPending(${respVar}) ? ${respVar}.data : undefined;
\`\`\`
<details><summary>Description</summary>
When you only need the most recent message (progress percentage, status line).
</details>

### 4) Controlled start/stop (user-triggered)
\`\`\`tsx
const [${respVar}, ${actionName}, ${clearName}] = use${pascalCase(descriptor.name)}();

const start = () => ${actionName}(${callArgs});
const stop  = () => ${clearName}();
\`\`\`
<details><summary>Description</summary>
Expose play/pause UI for long streams or admin tools.
</details>

---

## Full example (with flushSync option)

\`\`\`tsx
import { use${pascalCase(descriptor.name)} } from '@intrig/react/${descriptor.path}/client';
import { isPending, isSuccess, isError } from '@intrig/react';
import { useEffect, useState } from 'react';
import { flushSync } from 'react-dom';

function MyComponent() {
  const [${respVar}, ${actionName}] = use${pascalCase(descriptor.name)}({ clearOnUnmount: true });
  const [events, setEvents] = useState<any[]>([]);

  useEffect(() => {
    ${actionName}(${callArgs});
  }, [${actionName}]);

  useEffect(() => {
    if (isPending(${respVar})) {
      // Use flushSync only if you must render every single event (high-frequency streams).
      flushSync(() => setEvents((xs) => [...xs, ${respVar}.data]));
    }
  }, [${respVar}]);

  if (isError(${respVar})) return <>Stream error</>;
  return (
    <>
      {isPending(${respVar}) && <pre>{JSON.stringify(events, null, 2)}</pre>}
      {isSuccess(${respVar}) && <>Completed ({events.length} events)</>}
    </>
  );
}
\`\`\`

---

## Tips, anti-patterns & gotchas

- **Prefer \`clearOnUnmount: true\`** so the EventSource/web request is closed when the component disappears.
- **Don’t store unbounded arrays** for infinite streams—cap the length or batch to IndexedDB.
- **Avoid unnecessary \`flushSync\`**; it’s expensive. Use it only when you truly must render every event.
- **Multiple streams:** supply a unique \`key\` to isolate independent subscriptions.
- **Server requirements:** SSE endpoints should send \`Content-Type: text/event-stream\`, disable buffering, and flush regularly; add relevant CORS headers if needed.
- **Completion:** UI can switch from progress view (\`isPending\`) to final view (\`isSuccess\`) automatically.

---

## Troubleshooting

- **No intermediate messages:** ensure the server is truly streaming SSE (correct content type + flush) and that proxies/CDNs aren’t buffering responses.
- **UI not updating for each event:** remove expensive work from the event effect, consider throttling; only use \`flushSync\` if absolutely necessary.
- **Stream never completes:** check server end conditions and that you call \`${clearName}\` when appropriate.

`;
}
